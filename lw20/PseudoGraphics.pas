UNIT PseudoGraphics;

INTERFACE
  
PROCEDURE WriteSymbol(VAR Ch: CHAR; VAR FOut: TEXT);
PROCEDURE LoadAlphabet(VAR AplhabetFile: TEXT); 
FUNCTION PrintInline(VAR FIn, FOut: TEXT): BOOLEAN; { ?????????? True ???? ??? ?? ???? ?????????? }

IMPLEMENTATION

CONST 
  FIELD_WIDTH  = 5;
  FIELD_HEIGHT = 5;
  FIELD_AREA   = FIELD_WIDTH * FIELD_HEIGHT;

TYPE
  SymbolicChar = SET OF 1 .. FIELD_AREA;
  
VAR
  Symbols: ARRAY [CHAR] OF SymbolicChar;
  Filler: CHAR;
  
PROCEDURE WriteSymbol(VAR Ch: CHAR; VAR FOut: TEXT);
VAR
  I, J: INTEGER;
  CurrSymbolicChar: SymbolicChar;
BEGIN
  CurrSymbolicChar := Symbols[Ch];
  FOR I := 1 TO FIELD_AREA
  DO
    BEGIN  
      IF I IN CurrSymbolicChar
      THEN
        WRITE(Filler)
      ELSE
        WRITE(' '); 
        
      IF (I MOD FIELD_WIDTH) = 0
      THEN
        WRITELN   
    END
END;

PROCEDURE LoadAlphabet(VAR AplhabetFile: TEXT);
VAR
  I, J, Counter   : INTEGER;
  CurrCh, MaskCh  : CHAR;
  CurrSymbolicChar: SymbolicChar;
BEGIN
  WHILE NOT EOF(AplhabetFile)
  DO
    BEGIN
      READLN(AplhabetFile, CurrCh); { ????????? ???? }
      CurrSymbolicChar := [];       { ???????? ????????? ??? ????????????? }
      Counter := 1; 
      FOR I := 1 TO FIELD_HEIGHT
      DO 
        BEGIN
          FOR J := 1 TO FIELD_WIDTH
          DO
            BEGIN
              READ(AplhabetFile, MaskCh);  { ?????? ???????????? ?? ???? FIELD_HEIGHT*FIELD_WIDTH }
              IF MaskCh <> ' '
              THEN
                CurrSymbolicChar := CurrSymbolicChar + [Counter]; 
              Counter := Counter + 1  
            END;  
          READLN(AplhabetFile) { ?.?. ?????? ?????????, ?? ???????? ? ???????? ????? } 
        END;          
      Symbols[CurrCh] := CurrSymbolicChar { ????????? ?????? ? ??????? ????-???????? } 
    END
END;

FUNCTION PrintInline(VAR FIn, FOut: TEXT): BOOLEAN; 
CONST 
  MAX_COUNT = 10;
VAR
  SymbolicCache: ARRAY [1 .. MAX_COUNT] OF SymbolicChar;
  I, J, K, T, Base: INTEGER;
  CurrCh: CHAR;
BEGIN
  K := 1; { K ????? ??????? ? ???? ????? ????????? ??????? (???-?? ???????? ? SymbolicCache) }
  WHILE (NOT EOLN(FIn)) AND (K <= MAX_COUNT)
  DO
    BEGIN
      READ(FIn, CurrCh);
      SymbolicCache[K] := Symbols[CurrCh];
      K := K + 1
    END;
    
  Base := 0;
  IF K > 1
  THEN
    BEGIN
      FOR T := 1 TO FIELD_HEIGHT { ?????? ?????????, ?????????? ?? ??????? }
      DO 
        BEGIN
          FOR I := 1 TO K        { ?????????? ?? ?????????????? }
          DO
            BEGIN
              FOR J := 1 + Base TO FIELD_WIDTH + Base { ?????????? ?? ???????? ???? }
              DO
                BEGIN
                  IF J IN SymbolicCache[I]            { ?????????? ? ???????? ??????? ? ?????? ???}
                  THEN
                    WRITE(FOut, Filler)
                  ELSE
                    WRITE(FOut, ' ')    
                END;
              WRITE(FOut, '  ')      { ????????? ????????????? ????? ????????? ?????? ??? ??????? }
            END;
          WRITELN(FOut);
          Base := Base + FIELD_WIDTH; { ??????? ???? }
          PrintInline := TRUE; 
        END 
    END
  ELSE
    PrintInline := FALSE;  
END;

BEGIN
  Filler := '#'
END.
